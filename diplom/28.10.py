from ortools.linear_solver import pywraplp

# Создаем линейный решатель с помощью GLOP (Google Linear Optimization Package).
solver = pywraplp.Solver.CreateSolver('GLOP')
# Определяем переменные
I=2   #количество заданий, выполняемых в системе
L=3  #количество обрабатывающих приборов, входящих в конвейерную систему
W=2  #количество типов заданий, обрабатываемых в системе
J=3   #общее количество позиций, которые занимают ПЗ в последовательностях их вы-полнения на приборах КС
R = 2 ** 10000 #достаточно большие числа
V = 2 ** 9999

n_w=[ 1, 2 ]

T_l_w={}

for l in range(L):
    for w in range(I):
        T_l_w[l, w] = solver.NumVar(0, 100, f'T_l_w[{l},{w}]')

#T_l_w=[[0] * W for _ in range(L)] #матрица длительностей выполнения заданий w-х типов на l-х приборах КС


A_w_i=[[0] * I for _ in range(W)] #матрица, элементы которой определяют принадлежность i-х заданий w-м наборам


P_l_w=[[0] * W for _ in range(L)] #матрица длительностей переналадок приборов на выполнение заданий w-х типов



M_i_j=[[0] * J for _ in range(I)] #матрица индексов заданий, являющихся первыми в пакетах, занимающих j-е пози-ции в последовательностях их выполнения на приборах КС
m_i_1 = M_i_j[i][1]

X_j_l=[[0] * L for _ in range(J)] #матрица принадлежности i-х заданий пакетам, занимающих j-е позиции в последо-вательностях их выполнения на приборах КС


K_i_i=[[0] * I for _ in range(I)] #матрица порядка заданий i-х типов в пакетах


Q_l_i=[[0] * I for _ in range(L)] #матрица моментов времени начала выполнения i-х заданий на l-х приборах КС
q_l_i = int

G_l_i=[[0] * I for _ in range(L)] #матрица моментов времени окончания выполнения на l-х приборах ПЗ, занимаю-щих в последовательностях реализации действий с ними j-е позиции


print("T_l_w",T_l_w)
print("A_w_i",A_w_i)
print("P_l_w",P_l_w)
print("M_i_j",M_i_j)
print("X_j_l",X_j_l)
print("K_i_i",K_i_i)
print("Q_l_i",Q_l_i)
print("G_l_i",G_l_i)

#ограничения
# берем за ограничение что некоторые элементы больше или равны 0 : q_l_i, w_l_j, m_i_j
#1 ограничение
for l in range(L):
    for i in range(I):
        q_l_i_temp = Q_l_i[l][i]
        if q_l_i_temp >= R * (m_i_1 - 1):
            q_l_i = q_l_i_temp
            print(q_l_i)
# если первая буква l тогда можно таким образом наполнить матрицу верными элементами
# если первое - цифра одын, тогда мы определяем начало выполнения i-го задания для первой машины - что кстати странно, зачем нам узнавать i-е задание

#2 ограничение
# что такое qls??? точнее что такое s и где определяем



# Определяем целевую функцию
objective = solver.Objective()
for l in range(L):
    for i in range(I):
        objective.SetCoefficient(G_l_i[l][i], 1)  # Коэффициенты равны 1 для всех переменных
objective.SetMaximization()  # Установка цели на максимизацию

# Решение задачи
solver.Solve()
